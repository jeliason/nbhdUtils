---
title: "Spatial regression and ML techniques"
output:
  html_document:
    df_print: paged
---
```{r setup, include=FALSE}
library(tidyverse)
library(spdep)
library(spatialOnco)
library(spatialreg)
library(spatstat)
library(spatialRF)
library(spatgraphs)
library(brms)
library(DHARMa)

DATA_PATH = '../data/nbhd_coord_schurch_2020/'
RESULTS_PATH = '../results/spatial_reg_01122022/'
dir.create(RESULTS_PATH)
df = read_csv(paste0(DATA_PATH,'CRC_master.csv'))

spot.labels = c("15_A","15_B","16_A","16_B")
keep_types = unique(df$ClusterName)

nbhds = make_spot_nbhds(df,spot.labels,keep_types, radius = 50)

```

```{r}
feats = nbhds %>%
  named_group_split(spot, keep = FALSE)

coords = df %>% 
  rename(spot = spots) %>%
  filter(spot %in% spot.labels) %>%
  select(spot,X,Y) %>%
  named_group_split(spot, keep = FALSE)

spdfs = mapply(SpatialPointsDataFrame,coords,feats,SIMPLIFY = F)

spplot(spdfs[[1]],"tumor.cells")
```

##### Weights matrix for distances, CAR model with zero-inflated negative binomial

```{r}
D = dist(spdfs[[1]]@coords)
D = as.matrix(D)
dim(D)

nb.radius = 10
W = as.matrix((D<=nb.radius)+0)
diag(W) <- 0

d = nbhds[nbhds$spot == "15_A",]
N = dim(d)[1]
d = d %>% mutate(grp = factor(1:N))

rownames(W) = 1:N

fit.4.6 <- brm(formula = bf(tumor.cells ~ 1 + (CD4..T.cells.CD45RO. + CD68.CD163..macrophages + CD8..T.cells + Tregs + CD11b.CD68..macrophages + car(W,gr = grp,type="icar")), zi ~ 1),
  family = zero_inflated_negbinomial(),
  data = d,
  data2 = list(W = W),
  # control = list(adapt_delta = 0.99),
  iter = 2000,
  warmup = 1000,
  cores = 4,
  file = paste0(RESULTS_PATH,"fit.4.6")
) %>% add_criterion("loo")
summary(fit.4.6)
check.4.6 = check_brms(fit.4.6, plot = F)
testSpatialAutocorrelation(simulationOutput = check.4.6, x = d$X, y= d$Y)

tibble(X = d$X, Y = d$Y, res = check.4.6$scaledResiduals) %>%
  ggplot(aes(x = X, y = Y, colour = res)) +
  geom_point(alpha=0.7) + 
  scale_colour_gradient(low = "red", high = "blue")
```

#### Simpler (linear) models incorporating different spatial terms (spatial lagged, spatial Durbin error)


```{r}
fm = "tumor.cells ~ CD4..T.cells.CD45RO. + CD68.CD163..macrophages + CD8..T.cells + Tregs + CD11b.CD68..macrophages"

listw = spdep::mat2listw(W)

fit.4.7 = run_model(lmSLX,
                    file = paste0(RESULTS_PATH,"fit.4.7"),
                    fm,
                    data=d,
                    listw,
                    zero.policy=T)

summary(fit.4.7)

spatialreg::impacts(fit.4.7,listw)

fit.4.8 = run_model(errorsarlm,
                    file = paste0(RESULTS_PATH,"fit.4.8"),
                    fm,
                    data=d,
                    listw,
                    zero.policy = T)

summary(fit.4.8)

fit.4.9 = run_model(lm,
                    file = paste0(RESULTS_PATH,"fit.4.9"),
                    fm,
                    data=d)

lm.morantest(fit.4.9,listw,zero.policy = T)

lmLMtests <- lm.LMtests(fit.4.9, listw, test=c("LMerr", "LMlag", "RLMerr", "RLMlag", "SARMA"),zero.policy = T)

lm.morantest(fit.4.9,listw,zero.policy = T)
lm.morantest(fit.4.7,listw,zero.policy = T)
```

#### Moving to regular lattice for neighborhoods (for a smaller sample size)

```{r}
spot_eq = df %>%
  filter(spots == '15_A') %>%
  select(-`...1`)
keep_types = unique(spot_eq$ClusterName)
pat = create_ppp(spot_eq$X,spot_eq$Y,spot_eq$ClusterName,
                    keep_types = keep_types)

NUM_GRID = 25

find_center = function(x) {
  x = str_sub(x,start = 2,end=-2)
  l = str_split(x,",")
  start = as.numeric(l[[1]][1])
  end = as.numeric(l[[1]][2])
  mid = (start + end) / 2
  mid
}


q = quadratcount(split(pat),nx=NUM_GRID,ny=NUM_GRID)
q = sapply(seq_along(q),function(i) {
  tb = q[[i]]
  type = make.names(names(q))[[i]]
  tb = tb %>%
    as_tibble() %>%
    rename_with(~paste0(type),.cols=n)
  list(tb)
})


q_join = q %>%
  reduce(inner_join,by=c("x","y"))

q_join = q_join %>%
  mutate(x_c = Vectorize(find_center)(x)) %>%
  mutate(y_c = Vectorize(find_center)(y))

```

#### spatialRF


```{r}
# d = q_join
d = nbhds %>% filter(spot == "16_B")
dependent.variable.name = "tumor.cells"
predictor.variable.names = colnames(d %>% select(-c(X,Y,spot,tumor.cells)))
# predictor.variable.names = colnames(d %>% select(-c(x,y,x_c,y_c,tumor.cells)))

xy = d %>%
  select(c(X,Y)) %>%
  rename(x = X,y=Y) %>%
  as.data.frame()

xy_thin = thinning(xy,minimum.distance = 25)

# xy = d %>%
#   select(c(x_c,y_c)) %>%
#   rename(x=x_c,y=y_c) %>%
#   as.data.frame()
xy = xy_thin

distance.matrix = as.matrix(stats::dist(xy))


# data = d %>%
#   select(-c(x,y,x_c,y_c)) %>%
#   as.data.frame()

data = d %>%
  semi_join(.,xy,by=c("X"="x","Y"="y")) %>%
  select(-c(spot,X,Y))

sum(apply(data, 2, is.na))

predictor.variable.names = predictor.variable.names[apply(data[,predictor.variable.names], 2, var) != 0]

apply(data[,predictor.variable.names], 2, var) != 0
predictor.variable.names = predictor.variable.names[predictor.variable.names != "dirt"]

sum(predictor.variable.names %in% sapply(as.data.frame(scale(data)), function(x)any(is.nan(x))))

sapply(as.data.frame(scale(data)), function(x)any(is.infinite(x)))

distance.thresholds <- c(100,200,500,750,1000,1500,2000)

random.seed <- 2022
```

```{r}
spatialRF::plot_training_df_moran(
  data = data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  fill.color = viridis::viridis(
    100,
    option = "F",
    direction = -1
    ),
  point.color = "gray40"
)
```

```{r}
preference.order <- c(
    "CD8..T.cells",
    "Tregs",
    "Cd4..T.cells.CD45RO.",
    "CD68..macrophages",
    "CD11b.CD68..macrophages",
    "B.cells",
    "vasculature",
    "stroma"
  )

predictor.variable.names <- spatialRF::auto_cor(
  x = data[, predictor.variable.names],
  cor.threshold = 0.6,
  preference.order = preference.order
) %>%
  spatialRF::auto_vif(
    vif.threshold = 2.5,
    preference.order = preference.order
  )
```

```{r}
interactions.1 <- run_model(spatialRF::the_feature_engineer,
  file = paste0(RESULTS_PATH,"interactions.1"),
  data = data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  xy = xy,
  importance.threshold = 0.50, #uses 50% best predictors
  cor.threshold = 0.60, #max corr between interactions and predictors
  seed = random.seed,
  repetitions = 50,
  verbose = TRUE
  )
```

```{r}
#adding interaction column to the training data
if(!is.na(interactions.1)) {
  kableExtra::kbl(
  head(interactions.1$screening, 10),
  format = "html"
) %>%
  kableExtra::kable_paper("hover", full_width = F)
  
  data <- interactions.1$data

  #adding interaction name to predictor.variable.names
  predictor.variable.names <- interactions.1$predictor.variable.names
}
```

```{r}
fit.2 <- run_model(spatialRF::rf, 
  file = paste0(RESULTS_PATH,"fit.2"),
  data = data,
  dependent.variable.name = dependent.variable.name,
  predictor.variable.names = predictor.variable.names,
  distance.matrix = distance.matrix,
  distance.thresholds = distance.thresholds,
  xy = xy, #not needed by rf, but other functions read it from the model
  seed = random.seed,
  verbose = TRUE
)
```


```{r}
fit.3 <- run_model(spatialRF::rf_spatial,
  file = paste0(RESULTS_PATH,"fit.3"),
  model = fit.2,
  method = "mem.moran.sequential", #default method
  verbose = TRUE,
  seed = random.seed
  )
```

```{r}
spatialRF::plot_moran(
  fit.3,
  verbose = FALSE
  )
```


```{r}
p1 <- spatialRF::plot_importance(
  fit.2,
  verbose = FALSE) +
  ggplot2::ggtitle("Non-spatial model")

p2 <- spatialRF::plot_importance(
  fit.3,
  verbose = FALSE) +
  ggplot2::ggtitle("Spatial model")

p1 | p2
```

```{r}
kableExtra::kbl(
  head(fit.3$importance$per.variable, n = 10),
  format = "html"
) %>%
  kableExtra::kable_paper("hover", full_width = F)
```


Stiefel manifold - covariance matrices for important neighborhoods
GRAPHITE

Making DNNs more efficient
Modeling between-sample and within-sample

Integrative multi-omics - collaboration in prostate cancer
Radiomics - cross-correlations between different markers

Track software packages coming with the papers
GIOTTO 

tensor consisting of residuals from regressing one cell type on another
different scales for tensors

geographic diffusion of information

Jeff Regier
Brandon o'Connor - information geography
ACM Sig Spatial