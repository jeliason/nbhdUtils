---
title: "CytoMAP - extensions and replications"
output: html_notebook
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(spatgraphs)
library(spatialOnco)
```

#### Data IO/preprocessing

```{r}
DATA_PATH = '../data/nbhd_coord_schurch_2020/'
df = read_csv(paste0(DATA_PATH,'CRC_master.csv'))
pt_data = readxl::read_excel(paste0(DATA_PATH,'CRC_TMAs_patient_annotations.xlsx'))

```

```{r}
spot_eq = df %>%
  filter(spots == '15_B')
pat_eq = create_ppp(spot_eq$X,spot_eq$Y,spot_eq$ClusterName,
                    keep_types =c('Tregs','CD8+ T cells','vasculature','tumor cells'))
```

CytoMAP functionality to replicate:

1. cell type definition (passing on this for now, lots of examples)
2. Neighborhood definition (raster-scan vs graph based)
3. Neighborhood clustering (many ways of calculating neighborhood similarities)
  * Straight forward clusterings first...
  * Then things like graph embeddings
4. cell type correlations
5. distance to border or other landmark (may pass on this as well)
6. pseudospace
7. region visualization and statistics


### Neighborhoods

Ideally, we'd like to input a neighborhood type (w/ parameters) and point pattern, and get a list of neighborhoods out.

```{r}
sg_eq = spatgraph(pat_eq,type="SIG")
plot(sg_eq,pat_eq)

edgeLengths(sq_eq,pat_eq)

sg_to_nbhds = function(sg,pat) {
  edges = sg$edges
  marks = pat$marks
  cmarks = as.character(marks)
  nnodes = length(edges)
  nbhds = sapply(1:nnodes,function(i) {
    x = c(cmarks[i],cmarks[edges[[i]]])
    x = factor(x,levels=levels(marks))
    as.vector(table(x))
  })
  list(nbhds=t(nbhds),types=levels(marks))
}

nbhds.obj = sg_to_nbhds(sg_eq,pat_eq)
nbhds.obj

```

Scaling neighborhood composition:

1. comp (default) - divide by total number of cells
2. global

```{r}

nbhd_composition = function(nbhds.obj,scale="comp") {
  nbhds = nbhds.obj$nbhds
  if(scale == "comp") {
    sums = rowSums(nbhds)
    nbhds.obj$scaled_nbhds = sweep(nbhds,1,STATS=sums,FUN="/")
  } else if(scale == "global.comp") {
    nbhds.obj$scaled_nbhds = sweep(nbhds,2,STATS=apply(nbhds,2,max),FUN="/")
  } else if(scale == "binary") {
    nbhds.obj$scaled_nbhds = (nbhds > 0) + 0
  } else if(scale == "standardize") {
    nbhds.obj$scaled_nbhds = scale(nbhds,T,T)
  } else {
    stop("Not a recognized scaling!")
  }
    nbhds.obj$scaling = scale
  return(nbhds.obj)
}

nbhds.obj = nbhd_composition(nbhds.obj)
```


### Clustering algorithms for neighborhoods

hclust,kmeans,hdbscan,SOM,graph-based,affinity propagation using bluster


```{r}
library(bluster)
mat = nbhds.obj$scaled_nbhds
hclust.out <- clusterRows(mat, HclustParam())
hclust.out

```

```{r}
graph.out <- clusterRows(mat, NNGraphParam(k=10))
graph.out
```



